<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Manager</title>
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
<style>
        :root { --primary: #2563eb; --bg: #f8fafc; --sidebar: #1e293b; --text: #334155; }
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; display: flex; height: 100vh; background: var(--bg); color: var(--text); overflow: hidden; }
        
        /* ... (Keep Sidebar, Main, Toolbar, Content, Progress, Grid, Card styles same as before) ... */
        /* Paste the previous standard layout CSS here, or keep your existing one. */
        /* I will focus on the MAP fixes below */

        /* LAYOUT & SIDEBAR */
        .sidebar { width: 240px; background: var(--sidebar); color: white; padding: 20px; display: flex; flex-direction: column; flex-shrink: 0; z-index: 2000; }
        .nav-item { padding: 12px; cursor: pointer; border-radius: 6px; margin-bottom: 5px; transition: 0.2s; }
        .nav-item:hover, .nav-item.active { background: #334155; }
        .search-container { margin-bottom: 20px; }
        .search-input { width: 100%; padding: 10px; border-radius: 6px; border: none; background: #334155; color: white; box-sizing: border-box; }
        .progress-box { margin-top: auto; background: #0f172a; padding: 10px; border-radius: 6px; font-size: 0.8em; }
        .bar-bg { background: #334155; height: 6px; border-radius: 3px; margin: 5px 0; overflow: hidden; }
        .bar-fill { background: #22c55e; height: 100%; width: 0%; transition: width 0.3s; }
        
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .toolbar { padding: 15px; background: white; border-bottom: 1px solid #e2e8f0; display: flex; gap: 10px; align-items: center;}
        .content { flex: 1; overflow-y: auto; padding: 20px; position: relative; }
        
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; }
        .card { background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: pointer; transition: 0.2s; position: relative; }
        .card:hover { transform: translateY(-2px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); }
        .photo-img { width: 100%; height: 180px; object-fit: cover; }
        .play-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; opacity: 0.9; text-shadow: 0 0 10px rgba(0,0,0,0.5); pointer-events: none; }
        
        /* VIEWER */
        .viewer-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000; display: none; color: white; }
        .viewer-container { display: flex; width: 100%; height: 100%; }
        .viewer-main { flex: 1; position: relative; overflow: hidden; cursor: grab; background: #000; display: flex; justify-content: center; align-items: center; }
        .viewer-img { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; }
        .viewer-video { max-width: 100%; max-height: 100%; outline: none; }
        .viewer-sidebar { width: 320px; background: #1e1e1e; padding: 20px; overflow-y: auto; border-left: 1px solid #333; display: flex; flex-direction: column; gap: 20px; z-index: 10001; }
        .viewer-close { position: absolute; top: 20px; right: 20px; font-size: 2rem; cursor: pointer; z-index: 10002; background: rgba(0,0,0,0.5); width: 40px; height: 40px; text-align: center; line-height: 40px; border-radius: 50%; }
        .meta-row { display: flex; justify-content: space-between; font-size: 0.9rem; margin-bottom: 5px; }

        /* ---------- MAP ICON STYLES (APPLE STYLE) ---------- */
        #global-map { width: 100%; height: 100%; z-index: 1; }

        /* This is the container Leaflet uses. We reset styles to avoid border mess */
        .leaflet-cluster-wrapper {
            background: none !important;
            border: none !important;
        }

        /* The actual visible photo box */
        .map-photo-box {
            width: 50px; 
            height: 50px; 
            background-size: cover; 
            background-position: center; 
            border-radius: 8px; /* Rounded Square */
            border: 3px solid white; /* Thick white border */
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            position: relative;
            box-sizing: border-box; /* Crucial for sizing */
            transition: transform 0.2s;
        }
        .map-photo-box:hover { 
            transform: scale(1.15); 
            z-index: 9999;
        }

        /* The Red Notification Badge (Apple Style) */
        .map-badge-count {
            position: absolute;
            top: -8px; 
            right: -8px;
            background-color: #ff3b30; /* iOS Red */
            color: white;
            font-family: -apple-system, sans-serif;
            font-size: 11px;
            font-weight: 700;
            min-width: 18px;
            height: 18px;
            line-height: 18px;
            text-align: center;
            border-radius: 9px; /* Circle */
            border: 2px solid white; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        /* Album / Modal / Face styles (Keep existing) */
        .album-card { border-radius: 12px; overflow: visible; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; background: #fff; aspect-ratio: 1 / 1; }
        .album-cover { width: 100%; height: 100%; object-fit: cover; border-radius: 12px; }
        .album-badge { position: absolute; top: -8px; right: -8px; background-color: #ff3b30; color: white; font-size: 0.8rem; font-weight: bold; padding: 2px 8px; border-radius: 12px; border: 2px solid #f8fafc; box-shadow: 0 2px 4px rgba(0,0,0,0.2); min-width: 16px; text-align: center; z-index: 10; }
        .album-title { margin-top: 8px; font-weight: 600; font-size: 0.95rem; text-align: center; color: #334155; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .face-manage-card { position: relative; width: 120px; height: 120px; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: 0.2s; }
        .face-btn { position: absolute; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; cursor: pointer; border: 1px solid white; z-index: 10; color: white; }
        .btn-remove { top: 5px; right: 5px; background: rgba(239, 68, 68, 0.9); }
        .btn-star { top: 5px; left: 5px; background: rgba(234, 179, 8, 0.9); font-size: 12px; }
        .sidebar-face img { 
            width: 32px; height: 32px; 
            border-radius: 50%; 
            object-fit: cover; 
            object-position: center; /* Added */
            border: 1px solid #555; 
        }
        .face-manage-img { 
            width: 100%; height: 100%; 
            object-fit: cover; 
            object-position: center; /* Added */
        }

        .sidebar-face { 
            display: flex; align-items: center; gap: 10px; margin-bottom: 10px; 
            cursor: pointer; /* Added */
            transition: background 0.2s;
            padding: 5px;
            border-radius: 4px;
        }
        .sidebar-face:hover { background: rgba(255,255,255,0.1); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 10005; }
        .modal { background: white; padding: 25px; border-radius: 8px; width: 400px; max-width: 90%; color: #333; }
        .btn { padding: 8px 16px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-sec { background: #e2e8f0; color: #334155; }
        .card.selected { border: 3px solid var(--primary); background: #eff6ff; }
        .check-overlay { position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; border-radius: 50%; background: var(--primary); color: white; display: none; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 10; }
        .card.selected .check-overlay { display: flex; }
        .info { padding: 10px; font-size: 0.9em; }
        .filename-text { font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
        .face-bubbles { display: flex; gap: 5px; margin-top: 5px; overflow-x: auto; }
        .bubble { width: 25px; height: 25px; border-radius: 50%; border: 1px solid white; box-shadow: 0 1px 2px rgba(0,0,0,0.2); object-fit: cover; }
        .map-frame { width: 100%; height: 200px; border-radius: 8px; margin-top: 5px; background: #333; }
        .map-btn { display: block; width: 100%; text-align: center; background: #333; color: white; padding: 8px; border-radius: 6px; text-decoration: none; font-size: 0.9rem; margin-top: 5px; border: 1px solid #444; }
        input, select { width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; }
    
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.5);
            font-size: 40px;
            user-select: none;
            z-index: 10010; /* Above image but below sidebar if needed */
            transition: 0.2s;
            border-radius: 8px;
        }
        .nav-arrow:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .nav-prev { left: 10px; }
        .nav-next { right: 10px; }

        /* Hide arrows on mobile if needed, or make them smaller */
        @media (max-width: 768px) {
            .nav-arrow { width: 40px; font-size: 30px; }
        }
    
        /* COMMENT STYLES */
        .comment-section { margin-top: 20px; border-top: 1px solid #333; padding-top: 10px; }
        .comment-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px; max-height: 200px; overflow-y: auto; }
        .comment-item { background: #333; padding: 8px; border-radius: 6px; font-size: 0.9em; position: relative; }
        .comment-meta { font-size: 0.75em; color: #aaa; margin-bottom: 2px; display: flex; justify-content: space-between; }
        .comment-text { color: #eee; word-break: break-word; }
        .comment-del { cursor: pointer; color: #ef4444; }
        .comment-input-box { display: flex; gap: 5px; }
        .comment-input-box input { margin: 0; background: #333; color: white; border: 1px solid #444; }
    </style>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
</head>
<body>

    <div class="sidebar">
        <h2 style="margin-top:0">Photo Manager</h2>
        <div class="search-container"><input type="text" id="searchInput" class="search-input" placeholder="Search..." onkeydown="handleSearch(event)"></div>
        <div class="nav-item" id="nav-albums" onclick="loadDirectories()">üìÅ Albums</div>
        <div class="nav-item" id="nav-people" onclick="loadPeople()">üë• People</div>
        <div class="nav-item" id="nav-map" onclick="loadGlobalMap()">üåç Map</div>
        
        <div class="progress-box">
            <div style="display:flex; justify-content:space-between"><span>Scanner</span><span id="pct">0%</span></div>
            <div class="bar-bg"><div class="bar-fill" id="pbar"></div></div>
            <div id="pstatus">Idle</div>
            <button class="btn btn-primary" id="scanBtn" style="width:100%; margin-top:10px" onclick="startRefresh()">üîÑ Refresh</button>
        </div>
    </div>

    <div class="main">
        <div class="toolbar" id="toolbar"></div>
        <div class="content" id="content"></div>
    </div>

    <!-- VIEWER -->
    <div class="viewer-overlay" id="viewerOverlay">
        <div class="viewer-close" onclick="closeViewer()">√ó</div>
        <div class="viewer-container">
            <div class="viewer-main" id="viewerMain">
                <div class="nav-arrow nav-prev" onclick="navigateViewer(-1)">&#10094;</div>
                <div class="nav-arrow nav-next" onclick="navigateViewer(1)">&#10095;</div>
                <img id="detailImg" class="viewer-img">
                <video id="detailVideo" class="viewer-video" controls style="display:none"></video>
            </div>
            <div class="viewer-sidebar">
                <div style="border-bottom:1px solid #333; padding-bottom:10px; margin-bottom:10px">
                    <h3 id="dFileName" style="margin:0; font-size:1rem; word-break:break-all">-</h3>
                    <div id="dCreated" style="color:#888; font-size:0.8rem">-</div>
                </div>
                <div class="meta-row" style="display:block">
                    <div id="dFolder" style="margin-bottom:5px; color:#ddd"></div>
                    <div id="leafletMap" class="map-frame" style="display:none"></div>
                    <a id="appleMapsLink" href="#" target="_blank" class="map-btn">Open in Maps</a>
                </div>
                <div id="dFaces" style="margin-top:20px"></div>
                <!-- NEW COMMENT SECTION -->
                <div class="comment-section">
                    <h4 style="margin:0 0 10px 0">Comments</h4>
                    <div id="dComments" class="comment-list"></div>
                    <div class="comment-input-box">
                        <input type="text" id="newCommentText" placeholder="Add comment..." onkeydown="if(event.key==='Enter') postComment()">
                        <button class="btn btn-primary" onclick="postComment()">‚èé</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- EDIT MODAL -->
    <div class="modal-overlay" id="editModal">
        <div class="modal">
            <h3>Edit Person</h3>
            
            <!-- NEW: Avatar Display -->
            <div style="text-align:center; margin-bottom:20px">
                <img id="editAvatar" src="" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:4px solid #f1f5f9; box-shadow:0 2px 5px rgba(0,0,0,0.1)">
            </div>

            <input type="hidden" id="editId">
            <label>Name</label>
            <input type="text" id="editName">
            
            <label>Gender</label>
            <select id="editGender">
                <option value="Unknown">Unknown</option>
                <option value="Male">Male</option>
                <option value="Female">Female</option>
            </select>
            
            <hr style="border:0; border-top:1px solid #eee; margin:15px 0">
            
            <label style="color:red">Merge into...</label>
            <select id="mergeTarget"><option value="">-- No --</option></select>
            
            <div style="margin-top:20px; display:flex; justify-content:space-between">
                <button class="btn" style="background:#ef4444; color:white" onclick="deletePerson()">Delete</button>
                <div style="display:flex; gap:10px">
                    <button class="btn btn-sec" onclick="closeModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="savePerson()">Save</button>
                </div>
            </div>
            <input type="hidden" id="editMd5">
            <input type="hidden" id="editFaceId">
        </div>
    </div>

    <script>
        // --- GLOBAL MAP ---
// --- GLOBAL MAP (FIXED ANCHOR & NOTIFICATION BADGE) ---
        async function loadGlobalMap() {
            setActiveNav('nav-map');
            setToolbar('Map');
            document.getElementById('content').innerHTML = '<div id="global-map"></div>';
            
            const map = L.map('global-map').setView([20, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);
            
            // Generate the Icon HTML
            const createIcon = (thumbUrl, count) => {
                const badgeHtml = count > 1 
                    ? `<div class="map-badge-count">${count}</div>` 
                    : '';
                
                return L.divIcon({
                    html: `
                        <div class="map-photo-box" style="background-image:url('${thumbUrl}')">
                            ${badgeHtml}
                        </div>
                    `,
                    className: 'leaflet-cluster-wrapper', // Use our reset class
                    iconSize: [50, 50],   // Explicit Size
                    iconAnchor: [25, 25], // CRITICAL: Perfect Center
                });
            };

            const markers = L.markerClusterGroup({
                maxClusterRadius: 40,
                // Aggregated Cluster Icon (Many photos)
                iconCreateFunction: function(cluster) {
                    const children = cluster.getAllChildMarkers();
                    const count = cluster.getChildCount();
                    // Sort to find latest
                    children.sort((a, b) => b.options.customData.created.localeCompare(a.options.customData.created));
                    const latest = children[0];
                    const thumbUrl = latest.options.customData.thumb;
                    
                    return createIcon(thumbUrl, count);
                }
            });
            
            const res = await fetch('/api/map_all');
            const points = await res.json();

            currentPlaylist = points; 
            
            points.forEach(p => {
                // Single Marker Icon
                const icon = createIcon(p.thumb, 1);
                
                const m = L.marker([p.lat, p.lon], { 
                    icon: icon,
                    customData: { thumb: p.thumb, created: p.created } 
                });

                m.on('click', () => openViewer(p.md5));
                markers.addLayer(m);
            });
            
            map.addLayer(markers);
            if(points.length > 0) map.fitBounds(markers.getBounds());
        }
        // --- GRID RENDERER ---
        function renderPhotoGrid(photos, title) {
            currentPlaylist = photos; 

            setToolbar(title);
            if (photos.length===0) { document.getElementById('content').innerHTML='<div style="padding:20px">No items.</div>'; return; }
            let html = '<div class="grid">';
            photos.forEach(p => {
                let faces = p.faces.map(f => `<img src="/api/face_crop/${f.md5}/${f.face_id}" class="bubble" title="${f.name}" onerror="this.src='static/img/people.svg'">`).join('');
                let playOverlay = p.is_video ? '<div class="play-icon">‚ñ∂</div>' : '';
                html += `
                    <div class="card" onclick="openViewer('${p.md5}')">
                        <div style="position:relative">
                            <img src="${p.url}" class="photo-img" loading="lazy">
                            ${playOverlay}
                        </div>
                        <div class="info"><span class="filename-text">${p.filename}</span><div class="face-bubbles">${faces}</div></div>
                    </div>`;
            });
            document.getElementById('content').innerHTML = html + '</div>';
        }

        function navigateViewer(direction) {
            if (currentIdx === -1 || currentPlaylist.length === 0) return;

            // Calculate new index
            let newIdx = currentIdx + direction;

            // Optional: Loop functionality (Last -> First)
            if (newIdx >= currentPlaylist.length) newIdx = 0;
            if (newIdx < 0) newIdx = currentPlaylist.length - 1;

            // Open the new photo
            const nextItem = currentPlaylist[newIdx];
            openViewer(nextItem.md5);
        }

        // Add Keyboard Support (Left/Right Arrows)
        document.addEventListener('keydown', function(e) {
            if (document.getElementById('viewerOverlay').style.display === 'block') {
                if (e.key === "ArrowLeft") navigateViewer(-1);
                if (e.key === "ArrowRight") navigateViewer(1);
                if (e.key === "Escape") closeViewer();
            }
        });

        // --- VIEWER & ZOOM (FIXED SCALING) ---
        let sc=1,px=0,py=0,sx=0,sy=0,pan=false; 
        const ie=document.getElementById('detailImg'), vm=document.getElementById('viewerMain');
        
        function upT(){ ie.style.transform=`translate(${px}px,${py}px) scale(${sc})`; }
        
        function resetZoom(){ 
            if(!ie.naturalWidth)return; 
            const vw=vm.clientWidth, vh=vm.clientHeight;
            const iw=ie.naturalWidth, ih=ie.naturalHeight;
            
            // Calculate scale to FIT container
            let s=Math.min(vw/iw, vh/ih);
            
            // FIXED: Removed the (s > 1) cap. Now small images will scale up to fill screen.
            
            sc = s * 0.98; // 98% to leave tiny margin
            
            // Center
            px=(vw-(iw*sc))/2; 
            py=(vh-(ih*sc))/2; 
            upT(); 
        }

        vm.onwheel=e=>{ 
            if(ie.style.display=='none')return; 
            e.preventDefault(); 
            const r=vm.getBoundingClientRect();
            const mx=e.clientX-r.left, my=e.clientY-r.top;
            
            // Calculate mouse position relative to image content
            const xs=(mx-px)/sc, ys=(my-py)/sc;
            
            const d=-Math.sign(e.deltaY)*0.15;
            sc=Math.min(Math.max(0.1, sc+(sc*d)), 20); // Allowed bigger max zoom
            
            // Adjust px/py to keep mouse position stable
            px=mx-(xs*sc); 
            py=my-(ys*sc); 
            upT(); 
        };

        vm.onmousedown=e=>{ if(ie.style.display=='none')return; if(e.target===vm||e.target===ie){ pan=true; sx=e.clientX-px; sy=e.clientY-py; vm.style.cursor='grabbing'; }};
        window.onmousemove=e=>{ if(pan){ e.preventDefault(); px=e.clientX-sx; py=e.clientY-sy; upT(); }};
        window.onmouseup=()=>{ pan=false; vm.style.cursor='grab'; };

        // --- GLOBAL VIEWER STATE ---
        let currentPlaylist = []; // Stores the array of photo objects currently on screen
        let currentIdx = -1;      // Tracks which index we are viewing

        function openViewer(md5) {

            currentIdx = currentPlaylist.findIndex(p => p.md5 === md5);

            document.getElementById('viewerOverlay').style.display = 'block';
            const img = document.getElementById('detailImg');
            const vid = document.getElementById('detailVideo');
            const mapContainer = document.getElementById('leafletMap');
            
            // Reset
            img.style.display = 'block'; img.style.opacity = '0';
            vid.style.display = 'none'; vid.src = '';
            mapContainer.style.display = 'none';
            document.getElementById('dFaces').innerHTML = 'Loading...';

            fetch(`/api/photo_details/${md5}`)
                .then(r => r.json())
                .then(data => {
                    // ... (Keep existing Video/Image/Map logic) ...
                    if (data.is_video) {
                        img.style.display = 'none'; vid.style.display = 'block'; vid.src = `/image_by_md5/${md5}`; vid.play();
                    } else {
                        vid.style.display = 'none'; img.style.display = 'block'; img.src = `/image_by_md5/${md5}`; 
                        img.onload = () => { resetZoom(); img.style.opacity = '1'; };
                    }
                    
                    document.getElementById('dFileName').innerText = data.filename;
                    document.getElementById('dCreated').innerText = data.created;

                    const mapC = document.getElementById('leafletMap');
                    const appleBtn = document.getElementById('appleMapsLink');
                    if(data.gps) {
                        const [lat, lon] = data.gps.split(',');
                        initMap(parseFloat(lat), parseFloat(lon));
                        mapC.style.display='block';
                        appleBtn.href = `http://maps.apple.com/?q=${lat},${lon}`;
                    } else {
                        mapC.style.display='none';
                        appleBtn.href = `http://maps.apple.com/?q=${encodeURIComponent(data.location)}`;
                    }

                    // RENDER COMMENTS
                    const cList = document.getElementById('dComments');
                    cList.innerHTML = '';
                    if (data.comments) {
                        data.comments.forEach(c => {
                            const div = document.createElement('div');
                            div.className = 'comment-item';
                            // Allow deleting if we are the author (simple client check, real check on server)
                            const delBtn = `<span class="comment-del" onclick="deleteComment('${md5}', '${c.timestamp}')">√ó</span>`;
                            div.innerHTML = `
                                <div class="comment-meta">
                                    <span>${c.author} ‚Ä¢ ${c.timestamp}</span>
                                    ${delBtn}
                                </div>
                                <div class="comment-text">${c.text}</div>
                            `;
                            cList.appendChild(div);
                        });
                    }

                    // --- FIXED FACE LOGIC ---
                    let fHtml = '';
                    if (data.faces && data.faces.length > 0) {
                        data.faces.forEach(f => {
                            const isUnknown = f.cluster_id === "-1";
                            // Style: "Unknown" gets a dashed border or different opacity
                            const borderStyle = isUnknown ? "2px dashed #777" : "2px solid transparent";
                            
                            // CRITICAL: We pass cluster_id, md5, AND face_id
                            fHtml += `
                                <div class="sidebar-face" 
                                    onclick="openEdit('${f.cluster_id}', '${f.md5}', '${f.face_id}')" 
                                    title="${isUnknown ? 'Click to Identify' : 'Edit Person'}"
                                    style="cursor:pointer; display:flex; align-items:center; gap:10px; margin-bottom:8px; padding:4px; border-radius:4px; border:${borderStyle}">
                                    <img src="/api/face_crop/${f.md5}/${f.face_id}" style="width:32px; height:32px; border-radius:50%; object-fit:cover;">
                                    <span>${f.name}</span>
                                </div>
                            `;
                        });
                    }
                    document.getElementById('dFaces').innerHTML = fHtml || "<div style='color:#666'>No people detected</div>";
                });
        }
        function closeViewer() { 
            document.getElementById('viewerOverlay').style.display = 'none'; 
            document.getElementById('detailImg').src=''; 
            const vid = document.getElementById('detailVideo');
            vid.pause(); vid.src = '';
            document.getElementById('leafletMap').style.display='none'; 
        }

        // --- STANDARD UTILS ---
        function setActiveNav(id) { document.querySelectorAll('.nav-item').forEach(e=>e.classList.remove('active')); if(id) document.getElementById(id).classList.add('active'); }
        function setToolbar(html) { document.getElementById('toolbar').innerHTML = html; }
        
        async function loadDirectories() { setToolbar('Albums');setActiveNav('nav-albums'); const d = await (await fetch('/api/directories')).json(); let h='<div class="grid">'; d.forEach(x=>h+=`<div style="cursor:pointer" onclick="loadPhotos('${x.name}')"><div class="album-card"><img src="${x.cover}" class="album-cover" loading="lazy"><div class="album-badge">${x.count}</div></div><div class="album-title">${x.name}</div></div>`); document.getElementById('content').innerHTML=h+'</div>'; }
        
        async function loadPhotos(folder) { const p = await (await fetch(`/api/photos_by_dir?folder=${encodeURIComponent(folder)}`)).json(); renderPhotoGrid(p, `<button class="btn btn-sec" onclick="loadDirectories()">‚¨Ö Back</button> <b>${folder}</b>`); }
        async function handleSearch(e) {
            if(e.key==='Enter'){
                const q=document.getElementById('searchInput').value;
                if(q){
                    setActiveNav('');
                    const p = await (await fetch(`/api/search?q=${encodeURIComponent(q)}`)).json(); 
                    renderPhotoGrid(p, `Results: "${q}"`); 
                } else {
                    // Query is empty -> Go back to Albums
                    loadDirectories();
                }
            }
        }

        async function postComment() {
            if (currentIdx === -1) return;
            const md5 = currentPlaylist[currentIdx].md5;
            const txtInput = document.getElementById('newCommentText');
            const text = txtInput.value.trim();
            
            if (!text) return;

            const res = await fetch('/api/add_comment', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ md5: md5, text: text })
            });
            
            const r = await res.json();
            if (r.success) {
                txtInput.value = '';
                openViewer(md5); // Refresh sidebar
            } else {
                alert("Failed to post comment. Ensure you are logged in.");
            }
        }

        async function deleteComment(md5, timestamp) {
            if(!confirm("Delete comment?")) return;
            await fetch('/api/delete_comment', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ md5: md5, timestamp: timestamp })
            });
            openViewer(md5); // Refresh
        }


        // --- PEOPLE & SELECTION ---
        let isSel=false, selSet=new Set();
        async function loadPeople() {
            setActiveNav('nav-people');
            const p = await (await fetch('/api/people')).json();
            let toolbar = isSel ? `<button class="btn btn-sec" onclick="togSel()">Cancel</button> ${selSet.size} Selected <button class="btn" style="background:#ef4444;color:white;margin-left:auto" onclick="bulkDel()">Delete</button>` : `People <button class="btn btn-primary" onclick="togSel()" style="margin-left:auto">Select</button>`;
            setToolbar(toolbar);
            let h='<div class="grid">';
            p.forEach(x => {
                const s = selSet.has(x.id);
                h += `<div class="card ${s?'selected':''}" style="text-align:center;padding:15px" onclick="${isSel?`togP('${x.id}')`:`loadPersonDetail('${x.id}','${x.name}')`}"><img src="${x.avatar_url}" style="width:100px;height:100px;border-radius:50%;object-fit:cover" onerror="this.src='static/img/people.svg'"><div><b>${x.name}</b></div><div style="color:#666;font-size:0.8em">${x.count} photos</div>${!isSel?`<button class="btn btn-sec" style="margin-top:10px" onclick="event.stopPropagation();openEdit('${x.id}')">Edit</button>`:''}</div>`;
            });
            document.getElementById('content').innerHTML=h+'</div>';
        }
        function togSel() { isSel=!isSel; selSet.clear(); loadPeople(); }
        function togP(id) { if(selSet.has(id)) selSet.delete(id); else selSet.add(id); loadPeople(); }
        async function bulkDel() { if(confirm(`Delete ${selSet.size}?`)) { await fetch('/api/delete_people_bulk', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ids:Array.from(selSet)})}); togSel(); }}

        // --- FACE MANAGEMENT ---
        let currentPersonId = null;
        async function loadPersonDetail(pid, name) {
            currentPersonId = pid;
            setToolbar(`<button class="btn btn-sec" onclick="loadPeople()">‚¨Ö Back</button><span style="font-weight:bold; margin-left:10px">${name}</span>`);
            const faces = await (await fetch(`/api/faces_by_person/${pid}`)).json();
            let html = '<div class="grid" style="grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));">';
            faces.forEach(f => {
                html += `
                    <div class="face-manage-card" id="face-${f.face_id}">
                        <div class="face-btn btn-remove" onclick="removeFace('${f.md5}', '${f.face_id}', event)">‚úï</div>
                        <div class="face-btn btn-star" onclick="setAvatar('${f.md5}', '${f.face_id}', event)">‚òÖ</div>
                        <img src="${f.url}" class="face-manage-img" onclick="openViewer('${f.md5}')">
                    </div>`;
            });
            document.getElementById('content').innerHTML = html + '</div>';
        }
        async function setAvatar(md5, fid, e) { e.stopPropagation(); await fetch('/api/set_avatar', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({person_id:currentPersonId, md5, face_id:fid})}); alert("Avatar Updated!"); }

        // --- MAP UTILS ---
        let mapI=null; function initMap(lat,lon){ const e=document.getElementById('leafletMap'); e.style.display='block'; if(mapI)mapI.remove(); mapI=L.map('leafletMap').setView([lat,lon],13); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapI); L.marker([lat,lon]).addTo(mapI); }
        
        let allPeople=[]; 
        async function openEdit(clusterId, md5, faceId) {
            // 1. Store the specific face details (crucial for Unknowns)
            document.getElementById('editMd5').value = md5 || "";
            document.getElementById('editFaceId').value = faceId || "";

            // 2. Prepare the Modal
            const modal = document.getElementById('editModal');
            const nameInput = document.getElementById('editName');
            const genderInput = document.getElementById('editGender');
            const avatar = document.getElementById('editAvatar');
            const mergeSel = document.getElementById('mergeTarget');
            
            // Default State
            modal.style.display = 'flex';
            mergeSel.innerHTML = '<option>Loading...</option>';

            // 3. Logic Branch: Existing Person vs Unknown
            if (clusterId === "-1") {
                // --- UNKNOWN MODE ---
                document.getElementById('editId').value = "-1"; // Marker for "New"
                nameInput.value = "";
                nameInput.placeholder = "Enter Name for New Person...";
                genderInput.value = "Unknown";
                
                // Use the crop of the face we just clicked as the preview
                avatar.src = `/api/face_crop/${md5}/${faceId}`;
                
                // Helper text
                document.querySelector('.modal h3').innerText = "Identify Person";
            } else {
                // --- EDIT EXISTING MODE ---
                document.querySelector('.modal h3').innerText = "Edit Person";
                try {
                    const p = await (await fetch(`/api/person_details/${clusterId}`)).json();
                    document.getElementById('editId').value = p.id;
                    nameInput.value = p.name;
                    genderInput.value = p.gender;
                    avatar.src = p.avatar_url;
                } catch(e) { console.error(e); }
            }

            // 4. Load Merge/Assign Options
            // If Unknown: Dropdown says "Assign to existing..."
            // If Known: Dropdown says "Merge into..."
            const allPeople = await (await fetch('/api/people')).json();
            let opts = '<option value="">-- Create New (or No Change) --</option>';
            
            allPeople.forEach(p => {
                if (p.id !== clusterId) {
                    opts += `<option value="${p.id}">Assign to: ${p.name}</option>`;
                }
            });
            mergeSel.innerHTML = opts;
        }

        function closeModal() { document.getElementById('editModal').style.display='none'; }
        //async function savePerson() { const id=document.getElementById('editId').value, tid=document.getElementById('mergeTarget').value; if(tid){ if(confirm('Merge?')) await fetch('/api/merge_people', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({source_id:id, target_id:tid})}); } else { await fetch('/api/update_person', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id, name:document.getElementById('editName').value, gender:document.getElementById('editGender').value})}); } closeModal(); loadPeople(); }
        async function savePerson() {
            // 1. Get the ID loaded into the modal
            // If it's a new face, we set this to "-1" in openEdit()
            // If it's a deleted person, this is "a1b2..."
            const id = document.getElementById('editId').value; 
            
            const name = document.getElementById('editName').value;
            const gender = document.getElementById('editGender').value;
            const targetId = document.getElementById('mergeTarget').value; // If user selected someone to merge into
            
            // Hidden fields we added earlier
            const md5 = document.getElementById('editMd5').value;
            const faceId = document.getElementById('editFaceId').value;

            const headers = {'Content-Type':'application/json'};

            // --- SCENARIO A: Merging/Assigning to Existing ---
            if (targetId) {
                if (id === "-1") {
                    // It was unknown, now belongs to targetId
                    await fetch('/api/assign_face', {
                        method: 'POST', headers,
                        body: JSON.stringify({ md5, face_id: faceId, target_id: targetId })
                    });
                } else {
                    // It was someone else, now merging two people
                    if(confirm("Merge these people?")) {
                        await fetch('/api/merge_people', {
                            method: 'POST', headers,
                            body: JSON.stringify({ source_id: id, target_id: targetId })
                        });
                    }
                }
            } 
            // --- SCENARIO B: Creating NEW Person ---
            else if (id === "-1") {
                if (!name) return alert("Please enter a name for this new person");
                
                // THIS IS WHY YOU NEED create_person
                // We need to generate a UUID and write to people.json
                await fetch('/api/create_person', {
                    method: 'POST', headers,
                    body: JSON.stringify({ md5, face_id: faceId, name, gender })
                });
            } 
            // --- SCENARIO C: Updating/Restoring "Deleted" Person ---
            else {
                // This handles standard renaming AND "Undeleting"
                // The backend update_person should force is_deleted = False
                await fetch('/api/update_person', {
                    method: 'POST', headers,
                    body: JSON.stringify({ id, name, gender })
                });
            }

            closeModal();
            // Check if we are currently inside the Viewer
            const isViewerOpen = document.getElementById('viewerOverlay').style.display === 'block';

            if (isViewerOpen) {
                // SCENARIO A: We are in the Viewer.
                // Re-open the CURRENT photo to refresh the names in the sidebar.
                // We use the 'md5' hidden field which stores the photo we were looking at.
                if (md5) openViewer(md5);
            } else {
                // SCENARIO B: We are in the People Grid (or Map, or Album).
                // Do NOT open the viewer. 
                // Just refresh the background grid so the name/avatar updates.
                loadPeople(); 
            }
        }
        async function deletePerson() { const id=document.getElementById('editId').value; if(!confirm("Delete?")) return; await fetch('/api/delete_person', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:document.getElementById('editId').value})}); closeModal(); loadPeople(); }
        async function removeFace(md5, fid, e) { e.stopPropagation(); if(confirm('Remove?')) if((await (await fetch('/api/remove_face_from_cluster', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({md5, face_id:fid})})).json()).success) document.getElementById('face-'+fid).remove(); }




        // --- INIT ---
        let pt; async function startRefresh() { const r=await (await fetch('/api/refresh_library')).json(); if(r.status!=='error'){ document.getElementById('scanBtn').disabled=true; pt=setInterval(async()=>{ const s=await (await fetch('/api/scan_status')).json(); document.getElementById('pbar').style.width=s.progress+'%'; document.getElementById('pct').innerText=s.progress+'%'; document.getElementById('pstatus').innerText=s.current_task; if(!s.is_scanning && s.progress===100){ clearInterval(pt); document.getElementById('scanBtn').disabled=false; loadDirectories(); } }, 1000); }}
        function init(){ loadDirectories(); startRefresh(); }
        init();
    </script>
</body>
</html>